#!/usr/bin/env python3

'''
Does :

+ Run every 20 minutes : `restic backup`
+ Run every 10 iteration : `restic forget` (for the backup rotation)

It uses the following files to be configured :

+ ~/.enacrestic/bkp_include
  This is given to --files-from option
+ ~/.enacrestic/.pw
  This is given to --password-file option
+ ~/.enacrestic/env.sh
  This file has to configure env variables such as :
  + RESTIC_REPOSITORY
  + AWS_ACCESS_KEY_ID (if using S3)
  + AWS_SECRET_ACCESS_KEY (if using S3)

It writes to the following files :

+ ~/.enacrestic/last_backups.log
  All execution log
+ ~/.enacrestic/state.json
  State of previous execution
'''

import os
import re
import sys
import time
import json
import datetime
from PyQt5.QtGui import QIcon
from PyQt5.QtCore import QTimer, QProcess
from PyQt5.QtWidgets import QApplication, QSystemTrayIcon, QMenu

BACKUP_EVERY_N_MINUTES = 20
ROTATION_EVERY_N_ITERATIONS = 10

RESTIC_USER_PREFS = {
    'FILESFROM': os.path.expanduser('~/.restic/bkp_include'),
    'PASSWORDFILE': os.path.expanduser('~/.restic/.pw'),
}
RESTIC_LOGFILE = os.path.expanduser('~/.restic/last_backups.log')
RESTIC_STATEFILE = os.path.expanduser('~/.restic/state.json')

ICONS_FOLDER = os.path.abspath(f'{__file__}/../../share/pixmaps/enacrestic')

ICONS = {
    'program_just_launched':
        f'{ICONS_FOLDER}/just_launched.png',
    'backup_in_pause':
        f'{ICONS_FOLDER}/backup_in_pause.png',
    'backup_success':
        f'{ICONS_FOLDER}/backup_success.png',
    'backup_failed':
        f'{ICONS_FOLDER}/backup_failed.png',
    'backup_no_network':
        f'{ICONS_FOLDER}/backup_no_network.png',
    'backup_in_progress':
        f'{ICONS_FOLDER}/backup_in_progress.png',
    'backup_in_progress_failed':
        f'{ICONS_FOLDER}/backup_in_progress.png',
    'backup_in_progress_no_network':
        f'{ICONS_FOLDER}/backup_in_progress.png',
    'forget_in_progress':
        f'{ICONS_FOLDER}/forget_in_progress.png',
}


class Logger():
    '''
    Manages the writing to log file
    '''

    def __init__(self):
        pass

    def __enter__(self):
        self.f_handler = open(RESTIC_LOGFILE, 'a')
        return self

    def __exit__(self, typ, value, traceback):
        self.f_handler.close()

    def write_new_date_section(self):
        message = '-' * 50 + f'\n{datetime.datetime.now()}'
        self.write(message)

    def write(self, message='', end='\n'):
        self.f_handler.write(f'{message}{end}')
        self.f_handler.flush()
        print(message, end=end)

    def error(self, message, end='\n'):
        lines = [f'! {line}' for line in message.split('\n')]
        self.write('\n'.join(lines), end)


class State():
    '''
    Stores the state of the application
    Manages the transitions
    Updates the icon to match the state
    '''

    DEF_START_STATE = 'program_just_launched'
    DEF_NB_BACKUPS_BEFORE_FORGET = ROTATION_EVERY_N_ITERATIONS

    def __init__(self, tray_icon):
        self.tray_icon = tray_icon

    def __enter__(self):
        try:
            with open(RESTIC_STATEFILE) as fh:
                state_from_file = json.load(fh)
                self.current_state = state_from_file.get(
                    'current_state',
                    State.DEF_START_STATE
                )
                self.nb_backups_before_forget = state_from_file.get(
                    'nb_backups_before_forget',
                    State.DEF_NB_BACKUPS_BEFORE_FORGET
                )
        except FileNotFoundError:
            self.current_state = State.DEF_START_STATE
            self.nb_backups_before_forget = State.DEF_NB_BACKUPS_BEFORE_FORGET

        self._update_icon()
        return self

    def __exit__(self, typ, value, traceback):
        if self.current_state.startswith('backup_in_progress'):
            self.current_state = 'backup_failed'
        with open(RESTIC_STATEFILE, 'w') as fh:
            json.dump(
                {
                    'current_state': self.current_state,
                    'nb_backups_before_forget': self.nb_backups_before_forget,
                },
                fh
            )

    def want_to_backup(self):
        '''
        Answer if it is possible to run a backup
        it modifies the state (and icon if True)
        '''
        if self.current_state == 'program_just_launched':
            self.current_state = 'backup_in_progress'

        elif self.current_state == 'backup_in_pause':
            return False

        elif self.current_state == 'backup_success':
            self.current_state = 'backup_in_progress'

        elif self.current_state == 'backup_failed':
            self.current_state = 'backup_in_progress_failed'

        elif self.current_state == 'backup_no_network':
            self.current_state = 'backup_in_progress_no_network'

        elif self.current_state == 'backup_in_progress':
            return False

        elif self.current_state == 'backup_in_progress_failed':
            return False

        elif self.current_state == 'backup_in_progress_no_network':
            return False

        elif self.current_state == 'forget_in_progress':
            return False

        self._update_icon()
        return True

    def finished_restic_cmd(self, completion_status):
        '''
        Modify state because backup/forget command finished
        returns :
        + 'run forget' if it is the right condition to do so
        + 'ok' otherwise
        '''
        if completion_status == 'ok':
            if self.current_state == 'forget_in_progress':
                self.current_state = 'backup_success'
            else:  # that was a backup in progress
                self.nb_backups_before_forget -= 1
                if self.nb_backups_before_forget == 0:
                    self.nb_backups_before_forget = ROTATION_EVERY_N_ITERATIONS
                    self.current_state = 'forget_in_progress'
                else:
                    self.current_state = 'backup_success'
        elif completion_status == 'no network':
            self.current_state = 'backup_no_network'
        else:
            self.current_state = 'backup_failed'
        self._update_icon()
        if self.current_state == 'forget_in_progress':
            return 'run forget'
        else:
            return 'ok'

    def _update_icon(self):
        '''Update icon to current state'''
        print(f'update icon to {self.current_state}')
        self.tray_icon.setIcon(QIcon(ICONS[self.current_state]))


class ResticBackup():
    '''
    Manages the execution of restic command
    '''

    def __init__(self, state, logger):
        self.state = state
        self.logger = logger

    def run(self):
        logger.write_new_date_section()

        if not self.state.want_to_backup():
            logger.write(
                f'Backup not launched. '
                f'current state is {self.state.current_state}'
            )
            return

        # Run restic backup
        self._run_backup()
        logger.write()

    def _run_backup(self):
        logger.write('Running restic backup!')
        cmd = 'restic'
        args = [
            'backup',
            '--files-from', RESTIC_USER_PREFS['FILESFROM'],
            '--password-file', RESTIC_USER_PREFS['PASSWORDFILE']
        ]
        self._run(cmd, args)

    def _run_forget(self):
        logger.write('Running restic forget!')
        cmd = 'restic'
        args = [
            'forget', '--prune', '-g', 'host', '-c',
            '--password-file', RESTIC_USER_PREFS['PASSWORDFILE'],
            '--keep-last', '3',
            '--keep-hourly', '24',
            '--keep-daily', '7',
            '--keep-weekly', '4',
            '--keep-monthly', '12',
            '--keep-yearly', '5',
        ]
        self._run(cmd, args)

    def _run(self, cmd, args):
        self.p = QProcess()
        self.p.readyReadStandardOutput.connect(self._handle_stdout)
        self.p.readyReadStandardError.connect(self._handle_stderr)
        self.p.stateChanged.connect(self._handle_state)
        self.p.finished.connect(self._process_finished)
        self.p.start(cmd, args)
        self.current_error = ''

    def _handle_stdout(self):
        data = self.p.readAllStandardOutput()
        stdout = bytes(data).decode("utf8")
        logger.write(stdout)

    def _handle_stderr(self):
        data = self.p.readAllStandardError()
        stderr = bytes(data).decode("utf8")
        if re.search(r'timeout', stderr):
            self.current_error = 'timeout'
        logger.error(stderr)

    def _handle_state(self, proc_state):
        if proc_state == QProcess.Starting:
            self.current_time_starting = time.time()
        elif proc_state == QProcess.NotRunning:
            self.current_chrono = time.time() - self.current_time_starting

    def _process_finished(self):
        logger.write(
            f'Process finished in '
            f'{self.current_chrono:.3f} seconds.\n')
        next_action = ''
        if self.p.exitStatus() == QProcess.NormalExit:
            if self.p.exitCode() == 0:
                next_action = self.state.finished_restic_cmd('ok')
            else:
                if self.current_error == 'timeout':
                    self.state.finished_restic_cmd('no network')
                else:
                    self.state.finished_restic_cmd('failed')
        else:
            self.state.finished_restic_cmd('failed')

        self.p = None
        if next_action == 'run forget':
            self._run_forget()


if __name__ == '__main__':
    with Logger() as logger:
        app = QApplication(sys.argv)

        tray_icon = QSystemTrayIcon(
            QIcon(ICONS['program_just_launched']),
            parent=app
        )
        tray_icon.show()

        menu = QMenu()
        exitAction = menu.addAction('Exit')
        exitAction.triggered.connect(app.quit)

        tray_icon.setContextMenu(menu)

        with State(tray_icon) as state:
            restic_backup = ResticBackup(state, logger)
            timer = QTimer()
            timer.timeout.connect(restic_backup.run)
            timer.start(BACKUP_EVERY_N_MINUTES * 60 * 1000)

            logger.write_new_date_section()
            logger.write('Started ENACrestic application')

            sys.exit(app.exec_())
